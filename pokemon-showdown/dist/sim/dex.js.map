{
  "version": 3,
  "sources": ["../../sim/dex.ts"],
  "sourcesContent": ["/**\r\n * Dex\r\n * Pokemon Showdown - http://pokemonshowdown.com/\r\n *\r\n * Handles getting data about pokemon, items, etc. Also contains some useful\r\n * helper functions for using dex data.\r\n *\r\n * By default, nothing is loaded until you call Dex.mod(mod) or\r\n * Dex.forFormat(format).\r\n *\r\n * You may choose to preload some things:\r\n * - Dex.includeMods() ~10ms\r\n *   This will preload `Dex.dexes`, giving you a list of possible mods.\r\n * - Dex.includeFormats() ~30ms\r\n *   As above, but will also preload `Dex.formats.all()`.\r\n * - Dex.includeData() ~500ms\r\n *   As above, but will also preload all of Dex.data for Gen 8, so\r\n *   functions like `Dex.species.get`, etc will be instantly usable.\r\n * - Dex.includeModData() ~1500ms\r\n *   As above, but will also preload `Dex.dexes[...].data` for all mods.\r\n *\r\n * Note that preloading is never necessary. All the data will be\r\n * automatically preloaded when needed, preloading will just spend time\r\n * now so you don't need to spend time later.\r\n *\r\n * @license MIT\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport * as Data from './dex-data';\r\nimport { Condition, DexConditions } from './dex-conditions';\r\nimport { DataMove, DexMoves } from './dex-moves';\r\nimport { Item, DexItems } from './dex-items';\r\nimport { Ability, DexAbilities } from './dex-abilities';\r\nimport { Species, DexSpecies } from './dex-species';\r\nimport { Format, DexFormats } from './dex-formats';\r\nimport { Utils } from '../lib/utils';\r\n\r\nconst BASE_MOD = 'gen9' as ID;\r\nconst DATA_DIR = path.resolve(__dirname, '../data');\r\nconst MODS_DIR = path.resolve(DATA_DIR, './mods');\r\n\r\nconst dexes: { [mod: string]: ModdedDex } = Object.create(null);\r\n\r\ntype DataType =\r\n\t'Abilities' | 'Rulesets' | 'FormatsData' | 'Items' | 'Learnsets' | 'Moves' |\r\n\t'Natures' | 'Pokedex' | 'Scripts' | 'Conditions' | 'TypeChart' | 'PokemonGoData';\r\nconst DATA_TYPES: DataType[] = [\r\n\t'Abilities', 'Rulesets', 'FormatsData', 'Items', 'Learnsets', 'Moves',\r\n\t'Natures', 'Pokedex', 'Scripts', 'Conditions', 'TypeChart', 'PokemonGoData',\r\n];\r\n\r\nconst DATA_FILES = {\r\n\tAbilities: 'abilities',\r\n\tRulesets: 'rulesets',\r\n\tFormatsData: 'formats-data',\r\n\tItems: 'items',\r\n\tLearnsets: 'learnsets',\r\n\tMoves: 'moves',\r\n\tNatures: 'natures',\r\n\tPokedex: 'pokedex',\r\n\tPokemonGoData: 'pokemongo',\r\n\tScripts: 'scripts',\r\n\tConditions: 'conditions',\r\n\tTypeChart: 'typechart',\r\n};\r\n\r\n/** Unfortunately we do for..in too much to want to deal with the casts */\r\nexport interface DexTable<T> { [id: string]: T }\r\nexport interface AliasesTable { [id: IDEntry]: string }\r\n\r\ninterface DexTableData {\r\n\tAbilities: DexTable<import('./dex-abilities').AbilityData>;\r\n\tRulesets: DexTable<import('./dex-formats').FormatData>;\r\n\tItems: DexTable<import('./dex-items').ItemData>;\r\n\tLearnsets: DexTable<import('./dex-species').LearnsetData>;\r\n\tMoves: DexTable<import('./dex-moves').MoveData>;\r\n\tNatures: DexTable<import('./dex-data').NatureData>;\r\n\tPokedex: DexTable<import('./dex-species').SpeciesData>;\r\n\tFormatsData: DexTable<import('./dex-species').SpeciesFormatsData>;\r\n\tPokemonGoData: DexTable<import('./dex-species').PokemonGoData>;\r\n\tScripts: DexTable<AnyObject>;\r\n\tConditions: DexTable<import('./dex-conditions').ConditionData>;\r\n\tTypeChart: DexTable<import('./dex-data').TypeData>;\r\n}\r\ninterface TextTableData {\r\n\tAbilities: DexTable<AbilityText>;\r\n\tItems: DexTable<ItemText>;\r\n\tMoves: DexTable<MoveText>;\r\n\tPokedex: DexTable<PokedexText>;\r\n\tDefault: DexTable<DefaultText>;\r\n}\r\n\r\nexport const toID = Data.toID;\r\n\r\nexport class ModdedDex {\r\n\treadonly Data = Data;\r\n\treadonly Condition = Condition;\r\n\treadonly Ability = Ability;\r\n\treadonly Item = Item;\r\n\treadonly Move = DataMove;\r\n\treadonly Species = Species;\r\n\treadonly Format = Format;\r\n\treadonly ModdedDex = ModdedDex;\r\n\r\n\treadonly name = \"[ModdedDex]\";\r\n\treadonly isBase: boolean;\r\n\treadonly currentMod: string;\r\n\treadonly dataDir: string;\r\n\r\n\treadonly toID = Data.toID;\r\n\r\n\tgen = 0;\r\n\tparentMod = '';\r\n\tmodsLoaded = false;\r\n\r\n\tdataCache: DexTableData | null;\r\n\ttextCache: TextTableData | null;\r\n\r\n\tdeepClone = Utils.deepClone;\r\n\tdeepFreeze = Utils.deepFreeze;\r\n\tMultiset = Utils.Multiset;\r\n\r\n\treadonly formats: DexFormats;\r\n\treadonly abilities: DexAbilities;\r\n\treadonly items: DexItems;\r\n\treadonly moves: DexMoves;\r\n\treadonly species: DexSpecies;\r\n\treadonly conditions: DexConditions;\r\n\treadonly natures: Data.DexNatures;\r\n\treadonly types: Data.DexTypes;\r\n\treadonly stats: Data.DexStats;\r\n\treadonly aliases: Map<ID, ID> | null = null;\r\n\treadonly fuzzyAliases: Map<ID, ID[]> | null = null;\r\n\r\n\tconstructor(mod = 'base') {\r\n\t\tthis.isBase = (mod === 'base');\r\n\t\tthis.currentMod = mod;\r\n\t\tthis.dataDir = (this.isBase ? DATA_DIR : MODS_DIR + '/' + this.currentMod);\r\n\r\n\t\tthis.dataCache = null;\r\n\t\tthis.textCache = null;\r\n\r\n\t\tthis.formats = new DexFormats(this);\r\n\t\tthis.abilities = new DexAbilities(this);\r\n\t\tthis.items = new DexItems(this);\r\n\t\tthis.moves = new DexMoves(this);\r\n\t\tthis.species = new DexSpecies(this);\r\n\t\tthis.conditions = new DexConditions(this);\r\n\t\tthis.natures = new Data.DexNatures(this);\r\n\t\tthis.types = new Data.DexTypes(this);\r\n\t\tthis.stats = new Data.DexStats(this);\r\n\t}\r\n\r\n\tget data(): DexTableData {\r\n\t\treturn this.loadData();\r\n\t}\r\n\r\n\tget dexes(): { [mod: string]: ModdedDex } {\r\n\t\tthis.includeMods();\r\n\t\treturn dexes;\r\n\t}\r\n\r\n\tmod(mod: string | undefined): ModdedDex {\r\n\t\tif (!dexes['base'].modsLoaded) dexes['base'].includeMods();\r\n\t\treturn dexes[mod || 'base'].includeData();\r\n\t}\r\n\r\n\tforGen(gen: number) {\r\n\t\tif (!gen) return this;\r\n\t\treturn this.mod(`gen${gen}`);\r\n\t}\r\n\r\n\tforFormat(format: Format | string): ModdedDex {\r\n\t\tif (!this.modsLoaded) this.includeMods();\r\n\t\tconst mod = this.formats.get(format).mod;\r\n\t\treturn dexes[mod || BASE_MOD].includeData();\r\n\t}\r\n\r\n\tmodData(dataType: DataType, id: string) {\r\n\t\tif (this.isBase) return this.data[dataType][id];\r\n\t\tif (this.data[dataType][id] !== dexes[this.parentMod].data[dataType][id]) return this.data[dataType][id];\r\n\t\treturn (this.data[dataType][id] = Utils.deepClone(this.data[dataType][id]));\r\n\t}\r\n\r\n\teffectToString() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * Sanitizes a username or Pokemon nickname\r\n\t *\r\n\t * Returns the passed name, sanitized for safe use as a name in the PS\r\n\t * protocol.\r\n\t *\r\n\t * Such a string must uphold these guarantees:\r\n\t * - must not contain any ASCII whitespace character other than a space\r\n\t * - must not start or end with a space character\r\n\t * - must not contain any of: | , [ ]\r\n\t * - must not be the empty string\r\n\t * - must not contain Unicode RTL control characters\r\n\t *\r\n\t * If no such string can be found, returns the empty string. Calling\r\n\t * functions are expected to check for that condition and deal with it\r\n\t * accordingly.\r\n\t *\r\n\t * getName also enforces that there are not multiple consecutive space\r\n\t * characters in the name, although this is not strictly necessary for\r\n\t * safety.\r\n\t */\r\n\tgetName(name: any): string {\r\n\t\tif (typeof name !== 'string' && typeof name !== 'number') return '';\r\n\t\tname = `${name}`.replace(/[|\\s[\\],\\u202e]+/g, ' ').trim();\r\n\t\tif (name.length > 18) name = name.substr(0, 18).trim();\r\n\r\n\t\t// remove zalgo\r\n\t\tname = name.replace(\r\n\t\t\t/[\\u0300-\\u036f\\u0483-\\u0489\\u0610-\\u0615\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06ED\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E]{3,}/g,\r\n\t\t\t''\r\n\t\t);\r\n\t\tname = name.replace(/[\\u239b-\\u23b9]/g, '');\r\n\r\n\t\treturn name;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns false if the target is immune; true otherwise.\r\n\t * Also checks immunity to some statuses.\r\n\t */\r\n\tgetImmunity(\r\n\t\tsource: { type: string } | string,\r\n\t\ttarget: { getTypes: () => string[] } | { types: string[] } | string[] | string\r\n\t): boolean {\r\n\t\tconst sourceType: string = typeof source !== 'string' ? source.type : source;\r\n\t\t// @ts-expect-error really wish TS would support this\r\n\t\tconst targetTyping: string[] | string = target.getTypes?.() || target.types || target;\r\n\t\tif (Array.isArray(targetTyping)) {\r\n\t\t\tfor (const type of targetTyping) {\r\n\t\t\t\tif (!this.getImmunity(sourceType, type)) return false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tconst typeData = this.types.get(targetTyping);\r\n\t\tif (typeData && typeData.damageTaken[sourceType] === 3) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tgetEffectiveness(\r\n\t\tsource: { type: string } | string,\r\n\t\ttarget: { getTypes: () => string[] } | { types: string[] } | string[] | string\r\n\t): number {\r\n\t\tconst sourceType: string = typeof source !== 'string' ? source.type : source;\r\n\t\t// @ts-expect-error really wish TS would support this\r\n\t\tconst targetTyping: string[] | string = target.getTypes?.() || target.types || target;\r\n\t\tlet totalTypeMod = 0;\r\n\t\tif (Array.isArray(targetTyping)) {\r\n\t\t\tfor (const type of targetTyping) {\r\n\t\t\t\ttotalTypeMod += this.getEffectiveness(sourceType, type);\r\n\t\t\t}\r\n\t\t\treturn totalTypeMod;\r\n\t\t}\r\n\t\tconst typeData = this.types.get(targetTyping);\r\n\t\tif (!typeData) return 0;\r\n\t\tswitch (typeData.damageTaken[sourceType]) {\r\n\t\tcase 1: return 1; // super-effective\r\n\t\tcase 2: return -1; // resist\r\n\t\t// in case of weird situations like Gravity, immunity is handled elsewhere\r\n\t\tdefault: return 0;\r\n\t\t}\r\n\t}\r\n\r\n\tgetDescs(table: keyof TextTableData, id: ID, dataEntry: AnyObject) {\r\n\t\tif (dataEntry.shortDesc) {\r\n\t\t\treturn {\r\n\t\t\t\tdesc: dataEntry.desc,\r\n\t\t\t\tshortDesc: dataEntry.shortDesc,\r\n\t\t\t};\r\n\t\t}\r\n\t\tconst entry = this.loadTextData()[table][id];\r\n\t\tif (!entry) return null;\r\n\t\tconst descs = {\r\n\t\t\tdesc: '',\r\n\t\t\tshortDesc: '',\r\n\t\t};\r\n\t\tfor (let i = this.gen; i < dexes['base'].gen; i++) {\r\n\t\t\tconst curDesc = entry[`gen${i}` as keyof typeof entry]?.desc;\r\n\t\t\tconst curShortDesc = entry[`gen${i}` as keyof typeof entry]?.shortDesc;\r\n\t\t\tif (!descs.desc && curDesc) {\r\n\t\t\t\tdescs.desc = curDesc;\r\n\t\t\t}\r\n\t\t\tif (!descs.shortDesc && curShortDesc) {\r\n\t\t\t\tdescs.shortDesc = curShortDesc;\r\n\t\t\t}\r\n\t\t\tif (descs.desc && descs.shortDesc) break;\r\n\t\t}\r\n\t\tif (!descs.shortDesc) descs.shortDesc = entry.shortDesc || '';\r\n\t\tif (!descs.desc) descs.desc = entry.desc || descs.shortDesc;\r\n\t\treturn descs;\r\n\t}\r\n\r\n\t/**\r\n\t * Ensure we're working on a copy of a move (and make a copy if we aren't)\r\n\t *\r\n\t * Remember: \"ensure\" - by default, it won't make a copy of a copy:\r\n\t *     moveCopy === Dex.getActiveMove(moveCopy)\r\n\t *\r\n\t * If you really want to, use:\r\n\t *     moveCopyCopy = Dex.getActiveMove(moveCopy.id)\r\n\t */\r\n\tgetActiveMove(move: Move | string): ActiveMove {\r\n\t\tif (move && typeof (move as ActiveMove).hit === 'number') return move as ActiveMove;\r\n\t\tmove = this.moves.get(move);\r\n\t\tconst moveCopy: ActiveMove = this.deepClone(move);\r\n\t\tmoveCopy.hit = 0;\r\n\t\treturn moveCopy;\r\n\t}\r\n\r\n\tgetHiddenPower(ivs: StatsTable) {\r\n\t\tconst hpTypes = [\r\n\t\t\t'Fighting', 'Flying', 'Poison', 'Ground', 'Rock', 'Bug', 'Ghost', 'Steel',\r\n\t\t\t'Fire', 'Water', 'Grass', 'Electric', 'Psychic', 'Ice', 'Dragon', 'Dark',\r\n\t\t];\r\n\t\tconst tr = this.trunc;\r\n\t\tconst stats = { hp: 31, atk: 31, def: 31, spe: 31, spa: 31, spd: 31 };\r\n\t\tif (this.gen <= 2) {\r\n\t\t\t// Gen 2 specific Hidden Power check. IVs are still treated 0-31 so we get them 0-15\r\n\t\t\tconst atkDV = tr(ivs.atk / 2);\r\n\t\t\tconst defDV = tr(ivs.def / 2);\r\n\t\t\tconst speDV = tr(ivs.spe / 2);\r\n\t\t\tconst spcDV = tr(ivs.spa / 2);\r\n\t\t\treturn {\r\n\t\t\t\ttype: hpTypes[4 * (atkDV % 4) + (defDV % 4)],\r\n\t\t\t\tpower: tr(\r\n\t\t\t\t\t(5 * ((spcDV >> 3) + (2 * (speDV >> 3)) + (4 * (defDV >> 3)) + (8 * (atkDV >> 3))) + (spcDV % 4)) / 2 + 31\r\n\t\t\t\t),\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\t// Hidden Power check for Gen 3 onwards\r\n\t\t\tlet hpTypeX = 0;\r\n\t\t\tlet hpPowerX = 0;\r\n\t\t\tlet i = 1;\r\n\t\t\tfor (const s in stats) {\r\n\t\t\t\thpTypeX += i * (ivs[s as StatID] % 2);\r\n\t\t\t\thpPowerX += i * (tr(ivs[s as StatID] / 2) % 2);\r\n\t\t\t\ti *= 2;\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\ttype: hpTypes[tr(hpTypeX * 15 / 63)],\r\n\t\t\t\t// After Gen 6, Hidden Power is always 60 base power\r\n\t\t\t\tpower: (this.gen && this.gen < 6) ? tr(hpPowerX * 40 / 63) + 30 : 60,\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Truncate a number into an unsigned 32-bit integer, for\r\n\t * compatibility with the cartridge games' math systems.\r\n\t */\r\n\ttrunc(this: void, num: number, bits = 0) {\r\n\t\tif (bits) return (num >>> 0) % (2 ** bits);\r\n\t\treturn num >>> 0;\r\n\t}\r\n\r\n\tdataSearch(\r\n\t\ttarget: string,\r\n\t\tsearchIn?: ('Pokedex' | 'Moves' | 'Abilities' | 'Items' | 'Natures' | 'TypeChart')[] | null,\r\n\t\tisInexact?: boolean\r\n\t): AnyObject[] | null {\r\n\t\tif (!target) return null;\r\n\r\n\t\tsearchIn = searchIn || ['Pokedex', 'Moves', 'Abilities', 'Items', 'Natures'];\r\n\r\n\t\tconst searchObjects = {\r\n\t\t\tPokedex: 'species', Moves: 'moves', Abilities: 'abilities', Items: 'items', Natures: 'natures', TypeChart: 'types',\r\n\t\t} as const;\r\n\t\tconst searchTypes = {\r\n\t\t\tPokedex: 'pokemon', Moves: 'move', Abilities: 'ability', Items: 'item', Natures: 'nature', TypeChart: 'type',\r\n\t\t} as const;\r\n\t\tlet searchResults: AnyObject[] | null = [];\r\n\t\tfor (const table of searchIn) {\r\n\t\t\tconst res = this[searchObjects[table]].get(target);\r\n\t\t\tif (res.exists && res.gen <= this.gen) {\r\n\t\t\t\tsearchResults.push({\r\n\t\t\t\t\tisInexact,\r\n\t\t\t\t\tsearchType: searchTypes[table],\r\n\t\t\t\t\tname: res.name,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (searchResults.length) return searchResults;\r\n\t\tif (isInexact) return null; // prevent infinite loop\r\n\r\n\t\tthis.loadAliases();\r\n\t\tconst fuzzyAliases = Dex.fuzzyAliases!.get(toID(target));\r\n\t\tif (fuzzyAliases) {\r\n\t\t\tfor (const table of searchIn) {\r\n\t\t\t\tfor (const alias of fuzzyAliases) {\r\n\t\t\t\t\tconst res = this[searchObjects[table]].get(alias);\r\n\t\t\t\t\tif (res.exists && res.gen <= this.gen) {\r\n\t\t\t\t\t\tsearchResults.push({\r\n\t\t\t\t\t\t\tisInexact: true,\r\n\t\t\t\t\t\t\tsearchType: searchTypes[table],\r\n\t\t\t\t\t\t\tname: res.name,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (searchResults.length) return searchResults;\r\n\r\n\t\tconst cmpTarget = toID(target);\r\n\t\tlet maxLd = 3;\r\n\t\tif (cmpTarget.length <= 1) {\r\n\t\t\treturn null;\r\n\t\t} else if (cmpTarget.length <= 4) {\r\n\t\t\tmaxLd = 1;\r\n\t\t} else if (cmpTarget.length <= 6) {\r\n\t\t\tmaxLd = 2;\r\n\t\t}\r\n\t\tsearchResults = null;\r\n\t\tfor (const table of searchIn) {\r\n\t\t\tconst searchObj = this.data[table] as DexTable<any>;\r\n\t\t\tif (!searchObj) continue;\r\n\r\n\t\t\tfor (const j in searchObj) {\r\n\t\t\t\tconst ld = Utils.levenshtein(cmpTarget, j, maxLd);\r\n\t\t\t\tif (ld <= maxLd) {\r\n\t\t\t\t\tconst word = searchObj[j].name || j;\r\n\t\t\t\t\tconst results = this.dataSearch(word, searchIn, word);\r\n\t\t\t\t\tif (results) {\r\n\t\t\t\t\t\tsearchResults = results;\r\n\t\t\t\t\t\tmaxLd = ld;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn searchResults;\r\n\t}\r\n\r\n\tloadDataFile(basePath: string, dataType: DataType): AnyObject | void {\r\n\t\ttry {\r\n\t\t\tconst filePath = basePath + DATA_FILES[dataType];\r\n\t\t\tconst dataObject = require(filePath);\r\n\t\t\tif (!dataObject || typeof dataObject !== 'object') {\r\n\t\t\t\tthrow new TypeError(`${filePath}, if it exists, must export a non-null object`);\r\n\t\t\t}\r\n\t\t\tif (dataObject[dataType]?.constructor?.name !== 'Object') {\r\n\t\t\t\tthrow new TypeError(`${filePath}, if it exists, must export an object whose '${dataType}' property is an Object`);\r\n\t\t\t}\r\n\t\t\treturn dataObject[dataType];\r\n\t\t} catch (e: any) {\r\n\t\t\tif (e.code !== 'MODULE_NOT_FOUND' && e.code !== 'ENOENT') {\r\n\t\t\t\tthrow e;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tloadTextFile(\r\n\t\tname: string, exportName: string\r\n\t): DexTable<MoveText | ItemText | AbilityText | PokedexText | DefaultText> {\r\n\t\treturn require(`${DATA_DIR}/text/${name}`)[exportName];\r\n\t}\r\n\r\n\tincludeMods(): this {\r\n\t\tif (!this.isBase) throw new Error(`This must be called on the base Dex`);\r\n\t\tif (this.modsLoaded) return this;\r\n\r\n\t\tfor (const mod of fs.readdirSync(MODS_DIR)) {\r\n\t\t\tdexes[mod] = new ModdedDex(mod);\r\n\t\t}\r\n\t\tthis.modsLoaded = true;\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tincludeModData(): this {\r\n\t\tfor (const mod in this.dexes) {\r\n\t\t\tdexes[mod].includeData();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tincludeData(): this {\r\n\t\tthis.loadData();\r\n\t\treturn this;\r\n\t}\r\n\r\n\tloadTextData() {\r\n\t\tif (dexes['base'].textCache) return dexes['base'].textCache;\r\n\t\tdexes['base'].textCache = {\r\n\t\t\tPokedex: this.loadTextFile('pokedex', 'PokedexText') as DexTable<PokedexText>,\r\n\t\t\tMoves: this.loadTextFile('moves', 'MovesText') as DexTable<MoveText>,\r\n\t\t\tAbilities: this.loadTextFile('abilities', 'AbilitiesText') as DexTable<AbilityText>,\r\n\t\t\tItems: this.loadTextFile('items', 'ItemsText') as DexTable<ItemText>,\r\n\t\t\tDefault: this.loadTextFile('default', 'DefaultText') as DexTable<DefaultText>,\r\n\t\t};\r\n\t\treturn dexes['base'].textCache;\r\n\t}\r\n\r\n\tgetAlias(id: ID): ID | undefined {\r\n\t\treturn this.loadAliases().get(id);\r\n\t}\r\n\r\n\tloadAliases(): NonNullable<ModdedDex['aliases']> {\r\n\t\tif (!this.isBase) return Dex.loadAliases();\r\n\t\tif (this.aliases) return this.aliases;\r\n\t\tconst exported = require(path.resolve(DATA_DIR, 'aliases'));\r\n\t\tconst aliases = new Map<ID, ID>();\r\n\t\tfor (const [alias, target] of Object.entries(exported.Aliases)) {\r\n\t\t\taliases.set(alias as ID, toID(target));\r\n\t\t}\r\n\t\tconst compoundNames = new Map<ID, string>();\r\n\t\tfor (const name of exported.CompoundWordNames) {\r\n\t\t\tcompoundNames.set(toID(name), name);\r\n\t\t}\r\n\r\n\t\tconst fuzzyAliases = new Map<ID, ID[]>();\r\n\t\tconst addFuzzy = (alias: ID, target: ID) => {\r\n\t\t\tif (alias === target) return;\r\n\t\t\tif (alias.length < 2) return;\r\n\t\t\tconst prev = fuzzyAliases.get(alias) || [];\r\n\t\t\tif (!prev.includes(target)) prev.push(target);\r\n\t\t\tfuzzyAliases.set(alias, prev);\r\n\t\t};\r\n\t\tconst addFuzzyForme = (alias: ID, target: ID, forme: ID, formeLetter: ID) => {\r\n\t\t\taddFuzzy(`${alias}${forme}` as ID, target);\r\n\t\t\tif (!forme) return;\r\n\t\t\taddFuzzy(`${alias}${formeLetter}` as ID, target);\r\n\t\t\taddFuzzy(`${formeLetter}${alias}` as ID, target);\r\n\t\t\tif (forme === 'alola') addFuzzy(`alolan${alias}` as ID, target);\r\n\t\t\telse if (forme === 'galar') addFuzzy(`galarian${alias}` as ID, target);\r\n\t\t\telse if (forme === 'hisui') addFuzzy(`hisuian${alias}` as ID, target);\r\n\t\t\telse if (forme === 'paldea') addFuzzy(`paldean${alias}` as ID, target);\r\n\t\t\telse if (forme === 'megax') addFuzzy(`mega${alias}x` as ID, target);\r\n\t\t\telse if (forme === 'megay') addFuzzy(`mega${alias}y` as ID, target);\r\n\t\t\telse addFuzzy(`${forme}${alias}` as ID, target);\r\n\r\n\t\t\tif (forme === 'megax' || forme === 'megay') {\r\n\t\t\t\taddFuzzy(`mega${alias}` as ID, target);\r\n\t\t\t\taddFuzzy(`${alias}mega` as ID, target);\r\n\t\t\t\taddFuzzy(`m${alias}` as ID, target);\r\n\t\t\t\taddFuzzy(`${alias}m` as ID, target);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfor (const table of ['Items', 'Abilities', 'Moves', 'Pokedex'] as const) {\r\n\t\t\tconst data = this.data[table];\r\n\t\t\tfor (const [id, entry] of Object.entries(data) as [ID, DexTableData[typeof table][string]][]) {\r\n\t\t\t\tlet name = compoundNames.get(id) || entry.name;\r\n\t\t\t\tlet forme = '' as ID;\r\n\t\t\t\tlet formeLetter = '' as ID;\r\n\t\t\t\tif (name.includes('(')) {\r\n\t\t\t\t\taddFuzzy(toID(name.split('(')[0]), id);\r\n\t\t\t\t}\r\n\t\t\t\tif (table === 'Pokedex') {\r\n\t\t\t\t\t// can't Dex.species.get; aliases isn't loaded\r\n\t\t\t\t\tconst species = entry as DexTableData['Pokedex'][string];\r\n\t\t\t\t\tconst baseid = toID(species.baseSpecies);\r\n\t\t\t\t\tif (baseid && baseid !== id) {\r\n\t\t\t\t\t\tname = compoundNames.get(baseid) || baseid;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tforme = toID(species.forme || species.baseForme);\r\n\t\t\t\t\tif (forme === 'fan') {\r\n\t\t\t\t\t\tformeLetter = 's' as ID;\r\n\t\t\t\t\t} else if (forme === 'bloodmoon') {\r\n\t\t\t\t\t\tformeLetter = 'bm' as ID;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// not doing baseForme as a hack to make aliases point to base forme\r\n\t\t\t\t\t\tformeLetter = (species.forme || '').split(/ |-/).map(part => toID(part).charAt(0)).join('') as ID;\r\n\t\t\t\t\t}\r\n\t\t\t\t\taddFuzzy(forme, id);\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddFuzzyForme(toID(name), id, forme, formeLetter);\r\n\t\t\t\tconst fullSplit = name.split(/ |-/).map(toID);\r\n\t\t\t\tif (fullSplit.length < 2) continue;\r\n\t\t\t\tconst fullAcronym = fullSplit.map(x => x.charAt(0)).join('');\r\n\t\t\t\taddFuzzyForme(fullAcronym as ID, id, forme, formeLetter);\r\n\t\t\t\tconst fullAcronymWord = fullAcronym + fullSplit[fullSplit.length - 1].slice(1);\r\n\t\t\t\taddFuzzyForme(fullAcronymWord as ID, id, forme, formeLetter);\r\n\t\t\t\tfor (const wordPart of fullSplit) addFuzzyForme(wordPart, id, forme, formeLetter);\r\n\r\n\t\t\t\tconst spaceSplit = name.split(' ').map(toID);\r\n\t\t\t\tif (spaceSplit.length !== fullSplit.length) {\r\n\t\t\t\t\tconst spaceAcronym = spaceSplit.map(x => x.charAt(0)).join('');\r\n\t\t\t\t\taddFuzzyForme(spaceAcronym as ID, id, forme, formeLetter);\r\n\t\t\t\t\tconst spaceAcronymWord = spaceAcronym + spaceSplit[spaceSplit.length - 1].slice(1);\r\n\t\t\t\t\taddFuzzyForme(spaceAcronymWord as ID, id, forme, formeLetter);\r\n\t\t\t\t\tfor (const word of fullSplit) addFuzzyForme(word, id, forme, formeLetter);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t(this as any).aliases = aliases satisfies this['aliases'];\r\n\t\t(this as any).fuzzyAliases = fuzzyAliases satisfies this['fuzzyAliases'];\r\n\t\treturn this.aliases!;\r\n\t}\r\n\tloadData(): DexTableData {\r\n\t\tif (this.dataCache) return this.dataCache;\r\n\t\tdexes['base'].includeMods();\r\n\t\tconst dataCache: { [k in keyof DexTableData]?: any } = {};\r\n\r\n\t\tconst basePath = this.dataDir + '/';\r\n\r\n\t\tconst Scripts = this.loadDataFile(basePath, 'Scripts') || {};\r\n\t\t// We want to inherit most of Scripts but not this.\r\n\t\tconst init = Scripts.init;\r\n\t\tthis.parentMod = this.isBase ? '' : (Scripts.inherit || 'base');\r\n\r\n\t\tlet parentDex;\r\n\t\tif (this.parentMod) {\r\n\t\t\tparentDex = dexes[this.parentMod];\r\n\t\t\tif (!parentDex || parentDex === this) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Unable to load ${this.currentMod}. 'inherit' in scripts.ts should specify a parent mod from which to inherit data, or must be not specified.`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!parentDex) {\r\n\t\t\t// Formats are inherited by mods and used by Rulesets\r\n\t\t\tthis.includeFormats();\r\n\t\t}\r\n\t\tfor (const dataType of DATA_TYPES) {\r\n\t\t\tdataCache[dataType] = this.loadDataFile(basePath, dataType);\r\n\t\t\tif (dataType === 'Rulesets' && !parentDex) {\r\n\t\t\t\tfor (const format of this.formats.all()) {\r\n\t\t\t\t\tdataCache.Rulesets[format.id] = { ...format, ruleTable: null };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (parentDex) {\r\n\t\t\tfor (const dataType of DATA_TYPES) {\r\n\t\t\t\tconst parentTypedData: DexTable<any> = parentDex.data[dataType];\r\n\t\t\t\tif (!dataCache[dataType] && !init) {\r\n\t\t\t\t\tdataCache[dataType] = parentTypedData;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst childTypedData: DexTable<any> = dataCache[dataType] || (dataCache[dataType] = {});\r\n\t\t\t\tfor (const entryId in parentTypedData) {\r\n\t\t\t\t\tif (childTypedData[entryId] === null) {\r\n\t\t\t\t\t\t// null means don't inherit\r\n\t\t\t\t\t\tdelete childTypedData[entryId];\r\n\t\t\t\t\t} else if (!(entryId in childTypedData)) {\r\n\t\t\t\t\t\t// If it doesn't exist it's inherited from the parent data\r\n\t\t\t\t\t\tchildTypedData[entryId] = parentTypedData[entryId];\r\n\t\t\t\t\t} else if (childTypedData[entryId]?.inherit) {\r\n\t\t\t\t\t\t// {inherit: true} can be used to modify only parts of the parent data,\r\n\t\t\t\t\t\t// instead of overwriting entirely\r\n\t\t\t\t\t\tdelete childTypedData[entryId].inherit;\r\n\r\n\t\t\t\t\t\t// Merge parent and child's entry, with child overwriting parent.\r\n\t\t\t\t\t\tchildTypedData[entryId] = { ...parentTypedData[entryId], ...childTypedData[entryId] };\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Flag the generation. Required for team validator.\r\n\t\tthis.gen = dataCache.Scripts.gen;\r\n\t\tif (!this.gen) throw new Error(`Mod ${this.currentMod} needs a generation number in scripts.js`);\r\n\t\tthis.dataCache = dataCache as DexTableData;\r\n\r\n\t\t// Execute initialization script.\r\n\t\tif (init) init.call(this);\r\n\r\n\t\treturn this.dataCache;\r\n\t}\r\n\r\n\tincludeFormats(): this {\r\n\t\tthis.formats.load();\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\ndexes['base'] = new ModdedDex();\r\n\r\n// \"gen9\" is an alias for the current base data\r\ndexes[BASE_MOD] = dexes['base'];\r\n\r\nexport const Dex = dexes['base'];\r\nexport declare namespace Dex {\r\n\texport type Species = import('./dex-species').Species;\r\n\texport type Item = import('./dex-items').Item;\r\n\texport type Move = import('./dex-moves').Move;\r\n\texport type Ability = import('./dex-abilities').Ability;\r\n\r\n\texport type HitEffect = import('./dex-moves').HitEffect;\r\n\texport type SecondaryEffect = import('./dex-moves').SecondaryEffect;\r\n\texport type RuleTable = import('./dex-formats').RuleTable;\r\n\r\n\texport type GenderName = 'M' | 'F' | 'N' | '';\r\n\texport type StatIDExceptHP = 'atk' | 'def' | 'spa' | 'spd' | 'spe';\r\n\texport type StatID = 'hp' | StatIDExceptHP;\r\n\texport type StatsExceptHPTable = { [stat in StatIDExceptHP]: number };\r\n\texport type StatsTable = { [stat in StatID]: number };\r\n\texport type SparseStatsTable = Partial<StatsTable>;\r\n\texport type BoostID = StatIDExceptHP | 'accuracy' | 'evasion';\r\n\texport type BoostsTable = { [boost in BoostID]: number };\r\n\texport type SparseBoostsTable = Partial<BoostsTable>;\r\n}\r\n\r\nexport default Dex;\r\n"],
  "mappings": "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",
  "names": []
}
