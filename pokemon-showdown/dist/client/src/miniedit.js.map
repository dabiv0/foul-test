{
  "version": 3,
  "sources": ["../../../client/src/miniedit.ts"],
  "sourcesContent": ["// MiniEdit: ContentEditable-based rich source editor\r\n\r\n// True WYSIWYG is really complex, and <textarea> is really limited, but if you\r\n// have a use-case which is approximately \"syntax highlighting\", you can achieve\r\n// that relatively easily.\r\n\r\n// On Google, the most common hack for syntax highlighting is to put an invisible\r\n// <textarea> on top of syntax highlighted text, but this only works if your\r\n// text is monospace and syntax highlighting doesn't change its metrics. This\r\n// approach is more flexible and only requires textContent to be preserved.\r\n\r\n// Inspired by https://github.com/SjonHortensius/LRTEditor\r\n// and https://codepen.io/brianmearns/pen/YVjZWw?editors=0010\r\n\r\nconst MAX_UNDO_HISTORY = 100;\r\nexport type MiniEditPlugin = new (editor: MiniEdit) => unknown;\r\nexport type MiniEditSelection = { start: number, end: number } | null;\r\nexport class MiniEdit {\r\n\tstatic plugins: MiniEditPlugin[] = [];\r\n\r\n\telement: HTMLElement;\r\n\r\n\t/**\r\n\t * Takes the plaintext `textContent` of the element, and renders it\r\n\t * in syntax-highlighted form. This must not change the resulting\r\n\t * `textContent`, because the data needs to flow two ways to\r\n\t * correctly respond to all the possible ways users can input text.\r\n\t *\r\n\t * It should, however, add a trailing `\\n` if the text doesn't end\r\n\t * with one. This is because HTML ignores trailing newlines, so if\r\n\t * it doesn't already exist and the user types a newline at the end\r\n\t * of the text, it wouldn't appear.\r\n\t */\r\n\t_setContent: (text: string) => void;\r\n\tpushHistory?: (text: string, selection: MiniEditSelection) => void;\r\n\tonKeyDown = (ev: KeyboardEvent) => {\r\n\t\tif (ev.keyCode === 13) { // enter\r\n\t\t\tthis.replaceSelection('\\n');\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\t};\r\n\r\n\tconstructor(\r\n\t\tel: HTMLElement, options: { setContent: MiniEdit['_setContent'], onKeyDown?: (ev: KeyboardEvent) => void }\r\n\t) {\r\n\t\tthis.element = el;\r\n\r\n\t\tthis._setContent = options.setContent;\r\n\t\tthis.onKeyDown = options.onKeyDown || this.onKeyDown;\r\n\r\n\t\tthis.element.setAttribute('contentEditable', 'true');\r\n\t\tthis.element.setAttribute('autoComplete', 'off');\r\n\t\tthis.element.setAttribute('spellCheck', 'false');\r\n\t\tthis.element.addEventListener('input', () => {\r\n\t\t\tthis.reformat();\r\n\t\t});\r\n\t\tthis.element.addEventListener('keydown', this.onKeyDown);\r\n\r\n\t\tfor (const Plugin of MiniEdit.plugins) new Plugin(this);\r\n\t}\r\n\r\n\t/** return true from callback for an early return */\r\n\tprivate traverseText(node: Node, callback: (node: Text) => boolean): boolean {\r\n\t\tif (node.nodeType === 3) {\r\n\t\t\tif (callback(node as Text)) return true;\r\n\t\t} else {\r\n\t\t\tfor (let i = 0, len = node.childNodes.length; i < len; ++i) {\r\n\t\t\t\tif (this.traverseText(node.childNodes[i], callback)) return true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tsetValue(text: string, selection = this.getSelection()): void {\r\n\t\tthis._setContent(text);\r\n\r\n\t\tthis.setSelection(selection);\r\n\t\tthis.pushHistory?.(text, selection);\r\n\t}\r\n\tgetValue(): string {\r\n\t\tconst text = this.element.textContent || '';\r\n\t\tif (text.endsWith('\\n')) return text.slice(0, -1);\r\n\t\treturn text;\r\n\t}\r\n\treformat(selection?: MiniEditSelection): void {\r\n\t\tthis.setValue(this.getValue(), selection);\r\n\t}\r\n\treplaceSelection(text: string): void {\r\n\t\tconst selection = this.getSelection()!;\r\n\t\tconst oldContent = this.getValue();\r\n\t\tconst newText = oldContent.slice(0, selection.start) + text + oldContent.slice(selection.end);\r\n\t\tthis.setValue(newText, { start: selection.start + text.length, end: selection.start + text.length });\r\n\t}\r\n\r\n\tgetSelection(): MiniEditSelection {\r\n\t\tconst sel = window.getSelection()!;\r\n\t\tlet offset = 0;\r\n\t\tlet start = null as number | null;\r\n\t\tlet end = null as number | null;\r\n\r\n\t\tif (sel.rangeCount) {\r\n\t\t\tconst range = sel.getRangeAt(0);\r\n\t\t\tthis.traverseText(this.element, node => {\r\n\t\t\t\tif (start === null && node === range.startContainer) {\r\n\t\t\t\t\tstart = offset + range.startOffset;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (start !== null && node === range.endContainer) {\r\n\t\t\t\t\tend = offset + range.endOffset;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toffset += node.length;\r\n\t\t\t\treturn false;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn (start === null || end === null) ? null : { start, end };\r\n\t}\r\n\r\n\tsetSelection(sel: MiniEditSelection): void {\r\n\t\tif (sel === null) return;\r\n\r\n\t\tconst range = document.createRange();\r\n\t\tlet offset = 0;\r\n\t\tlet found = false;\r\n\t\trange.collapse(true);\r\n\r\n\t\tif (this.traverseText(this.element, n => {\r\n\t\t\tconst nextOffset = offset + n.length;\r\n\r\n\t\t\tif (!found && sel.start >= offset && sel.start <= nextOffset) {\r\n\t\t\t\trange.setStart(n, sel.start - offset);\r\n\t\t\t\tfound = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (found && sel.end >= offset && sel.end <= nextOffset) {\r\n\t\t\t\trange.setEnd(n, sel.end - offset);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\toffset = nextOffset;\r\n\t\t\treturn false;\r\n\t\t})) {\r\n\t\t\tconst selection = window.getSelection()!;\r\n\t\t\tselection.removeAllRanges();\r\n\t\t\tselection.addRange(range);\r\n\t\t}\r\n\t}\r\n\tselect(): void {\r\n\t\tthis.setSelection({ start: 0, end: this.getValue().length });\r\n\t}\r\n}\r\n\r\nexport class MiniEditPastePlugin {\r\n\tconstructor(editor: MiniEdit) {\r\n\t\teditor.element.addEventListener('paste', e => {\r\n\t\t\t// Manually insert plain-text contents so we keep newlines\r\n\t\t\tconst text = e.clipboardData!.getData('text/plain');\r\n\t\t\teditor.replaceSelection(text);\r\n\t\t\te.preventDefault();\r\n\t\t});\r\n\t}\r\n}\r\nMiniEdit.plugins.push(MiniEditPastePlugin);\r\n\r\n// We can't use the native undo/redo feature because browsers just get so\r\n// confused by our syntax highlighting, so we have to reimplement it.\r\n// We can intercept ctrl+z and ctrl+y, but we can't intercept the browser's\r\n// UI so things like Edit -> Undo will simply not work. I am sorry to say\r\n// that there is no solution and this is just what webdev is like.\r\nexport class MiniEditUndoPlugin {\r\n\teditor: MiniEdit;\r\n\tundoIndex: number | null = null;\r\n\tignoreInput = false;\r\n\thistory: { text: string, selection: MiniEditSelection }[] = [];\r\n\r\n\tconstructor(editor: MiniEdit) {\r\n\t\tthis.editor = editor;\r\n\t\tthis.history.push({ text: editor.getValue(), selection: { start: 0, end: 0 } });\r\n\r\n\t\tthis.editor.pushHistory = this.onPushHistory;\r\n\t\teditor.element.addEventListener('keydown', this.onKeyDown);\r\n\t}\r\n\r\n\tonPushHistory = (text: string, selection: MiniEditSelection) => {\r\n\t\tif (this.ignoreInput) {\r\n\t\t\t// This change was triggered by undo/redo, don't record it\r\n\t\t\tthis.ignoreInput = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (this.undoIndex !== null) {\r\n\t\t\t// chop off everything after the current undo index\r\n\t\t\tthis.history.splice(this.undoIndex + 1);\r\n\t\t\tthis.undoIndex = null;\r\n\t\t}\r\n\r\n\t\tthis.history.push({ text, selection });\r\n\r\n\t\tif (this.history.length > MAX_UNDO_HISTORY) this.history.shift();\r\n\t};\r\n\r\n\tonKeyDown = (e: KeyboardEvent) => {\r\n\t\t// ctrl+z or cmd+z\r\n\t\tconst undoPressed = (e.ctrlKey && e.keyCode === 90) || (e.metaKey && !e.shiftKey && e.keyCode === 90);\r\n\t\t// ctrl+y or cmd+shift+z\r\n\t\tconst redoPressed = (e.ctrlKey && e.keyCode === 89) || (e.metaKey && e.shiftKey && e.keyCode === 90);\r\n\r\n\t\tif (undoPressed) {\r\n\t\t\tthis.undoIndex ??= this.history.length - 1;\r\n\t\t\tthis.undoIndex--;\r\n\r\n\t\t\tif (this.undoIndex < 0) { // can't undo further\r\n\t\t\t\tthis.undoIndex = 0;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else if (redoPressed && this.undoIndex !== null) {\r\n\t\t\tthis.undoIndex++;\r\n\r\n\t\t\tif (this.undoIndex > this.history.length - 1) { // can't redo further\r\n\t\t\t\tthis.undoIndex = null;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst { text, selection } = this.history[this.undoIndex];\r\n\t\tthis.ignoreInput = true;\r\n\t\tthis.editor.setValue(text, selection);\r\n\t};\r\n}\r\nMiniEdit.plugins.push(MiniEditUndoPlugin);\r\n"],
  "mappings": "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",
  "names": []
}
